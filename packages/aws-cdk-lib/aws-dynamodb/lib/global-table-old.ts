import { Construct } from 'constructs';
import { CfnGlobalTable } from './dynamodb.generated';
import {
  SchemaOptions, TableClass, BillingMode, Attribute,
  GlobalSecondaryIndexProps, LocalSecondaryIndexProps,
} from './table';
import { IStream } from '../../aws-kinesis';
import { IResource, Lazy, RemovalPolicy, Resource } from '../../core';

const NEW_AND_OLD_IMAGES = 'NEW_AND_OLD_IMAGES';
const HASH_KEY_TYPE = 'HASH';
const RANGE_KEY_TYPE = 'RANGE';
const DEFAULT_TARGET_UTILIZATION = 70;

/**
 * Options used to configure a Capacity instance.
 */
interface CapacityOptions {
  /**
   * The number of capacity units.
   *
   * @default - no capacity units
   */
  readonly units?: number;

  /**
   * Options for configuring autoscaled capacity mode.
   *
   * @default - no autoscaled capacity options.
   */
  readonly autoscaledCapacityOptions?: AutoscaledCapacityOptions;
}

/**
 * Options to configure provisioned throughput for a table.
 */
export interface ThroughputOptions {
  /**
   *
   */
  readonly readCapacity: Capacity;

  /**
   *
   */
  readonly writeCapacity: Capacity;
}

/**
 * Options used to configure autoscaled capacity mode.
 */
export interface AutoscaledCapacityOptions {
  /**
   * The minimum capacity to scale to.
   */
  readonly minCapacity: number;

  /**
   * The maximum capacity to scale to.
   */
  readonly maxCapacity: number;

  /**
   * The target utilization percentage.
   *
   * @default 70
   */
  readonly targetUtilizationPercent?: number;
}

/**
 * Options used to configure a global secondary index for a replica table.
 */
export interface ReplicaGlobalSecondaryIndexOptions {
  /**
   *
   */
  readonly indexName: string;

  /**
   *
   */
  readonly readCapacity?: Capacity;

  /**
   * Whether or not CloudWatch contributor insights is enabled for the index.
   *
   * @default false
   */
  readonly contributorInsights?: boolean;
}

/**
 * Common table configuration options between a global table and its replicas.
 */
interface TableOptions {
  /**
   * Whether or not CloudWatch contributor insights is enabled for all replicas in the
   * global table.
   *
   * NOTE: This property is configurable on a per-replica basis.
   *
   * @default false
   */
  readonly contributorInsights?: boolean;

  /**
   * Whether or not deletion protection is enabled for all replicas in the global table.
   *
   * NOTE: This property is configurable on a per-replica basis.
   *
   * @default false
   */
  readonly deletionProtection?: boolean;

  /**
   * Whether or not point-in-time recovery is enabled for all replicas in the global table.
   *
   * NOTE: This property is configurable on a per-replica basis.
   *
   * @default false
   */
  readonly pointInTimeRecovery?: boolean;

  /**
   * The table class for all replicas in the global table.
   *
   * NOTE: This property is configurable on a per-replica basis.
   *
   * @default TableClass.STANDARD
   */
  readonly tableClass?: TableClass
}

/**
 * Options used to configure a replica table.
 */
export interface ReplicaTableOptions extends TableOptions {
  /**
   * The region in which the replica exists.
   */
  readonly region: string;

  /**
   * The kinesis data stream configuration to capture item-level changes for the replica.
   *
   * @default - no kinesis data stream
   */
  readonly kinesisStream?: IStream;

  /**
   *
   */
  readonly readCapacity?: Capacity;

  /**
   *
   */
  readonly globalSecondaryIndexes?: ReplicaGlobalSecondaryIndexOptions[];
}

/**
 * Properties for global tables.
 */
export interface GlobalTableProps extends TableOptions, SchemaOptions {
  /**
   * The name of all replicas in the global table.
   *
   * @default - generated by CloudFormation
   */
  readonly tableName?: string;

  /**
   * The name of the TTL attribute for all replicas in the global table.
   *
   * @default - TTL is disabled
   */
  readonly timeToLiveAttribute?: string;

  /**
   * The removal policy to apply to all replicas in the global table.
   *
   * @default RemovalPolicy.RETAIN
   */
  readonly removalPolicy?: RemovalPolicy;

  /**
   * The billing used for all replicas in the global table. The billing is used to specify
   * how you are charged for read and write throughput and how you manage capacity.
   *
   * @default BillingMode.onDemand()
   */
  readonly billing?: Billing;

  /**
   * The list of replicas in the global table.
   *
   * NOTE: You can create a new global table with as many replicas as needed. You can add or
   * remove replicas after table creation, but you can only add or remove a single replica in
   * each update.
   *
   * @default - a single replica will exist in the region associated with the deployment stack
   */
  readonly replicas?: ReplicaTableOptions[];

  /**
   * Global secondary indexes to be created on all replicas in the global table.
   *
   * NOTE: You can create up to 20 global secondary indexes. You can only create or delete one global
   * secondary index in a single stack operation. By default, each replica in your global table will
   * have the same global secondary index settings. However, the `readCapacity` of a global secondary
   * index can be set on a per-replica basis.
   *
   * @default - no global secondary indexes
   */
  readonly globalSecondaryIndexes?: GlobalSecondaryIndexProps[];

  /**
   * Local secondary indexes to be created on all replicas in the global table.
   *
   * NOTE: You can create up to five local secondary indexes. Each index is scoped to a given hash
   * key value. The size of each hash key can be up to 10 gigabytes. Each replica in your global
   * table will have the same local secondary index settings.
   *
   * @default - no local secondary indexes
   */
  readonly localSecondaryIndexes?: LocalSecondaryIndexProps[];

  /**
   * The server-side encryption to use on all replicas in the global table.
   *
   * @default TableEncryption.dynamoOwnedKey()
   */
  readonly encryption?: Encryption;
}

/**
 * Represents a global table.
 */
export interface IGlobalTable extends IResource {
  /**
   * The ARN of the replica in the region that the stack is deployed to.
   *
   * @attribute
   */
  readonly tableArn: string;

  /**
   * The name of all replicas in the global table.
   *
   * @attribute
   */
  readonly tableName: string;

  /**
   * The ID of the replica in the region that the stack is deployed to.
   *
   * @attribute
   */
  readonly tableId: string;

  /**
   * The ARN of the stream of the replica in the region that the stack is deployed to.
   *
   * @attribute
   */
  readonly tableStreamArn: string;
}

/**
 * Attributes of a global table.
 */
export interface GlobalTableAttributes {}

/**
 * Base class for a global table.
 */
abstract class GlobalTableBase extends Resource implements IGlobalTable {
  /**
   * The ARN of the replica in the region that the stack is deployed to.
   *
   * @attribute
   */
  public abstract readonly tableArn: string;

  /**
   * The name of all replicas in the global table.
   *
   * @attribute
   */
  public abstract readonly tableName: string;

  /**
   * The ID of the replica in the region that the stack is deployed to.
   *
   * @attribute
   */
  public abstract readonly tableId: string;

  /**
   * The ARN of the stream of the replica in the region that the stack is deployed to.
   *
   * @attribute
   */
  public abstract readonly tableStreamArn: string;
}

export class GlobalTable extends GlobalTableBase {
  /**
   * Returns the ARN of the replica in the region that the stack is deployed to.
   */
  public readonly tableArn: string;

  /**
   * Returns the name of all replicas in the global table.
   */
  public readonly tableName: string;

  /**
   * Returns the ID of the replica in the region that the stack is deployed to.
   */
  public readonly tableId: string;

  /**
   * Returns the ARN of the stream of the replica in the region that the stack is deployed to.
   */
  public readonly tableStreamArn: string;

  private readonly keySchema: CfnGlobalTable.KeySchemaProperty[] = [];
  private readonly attributeDefinitions: CfnGlobalTable.AttributeDefinitionProperty[] = [];
  private readonly replicas: CfnGlobalTable.ReplicaSpecificationProperty[] = [];
  private readonly globalSecondaryIndexes: GlobalSecondaryIndexProps[];
  private readonly billingMode: string;

  constructor(scope: Construct, id: string, props: GlobalTableProps) {
    super(scope, id, { physicalName: props.tableName });

    this.addKey(props.partitionKey, HASH_KEY_TYPE);
    if (props.sortKey) {
      this.addKey(props.sortKey, RANGE_KEY_TYPE);
    }

    this.globalSecondaryIndexes = props.globalSecondaryIndexes
      ? [...props.globalSecondaryIndexes]
      : [];

    this.billingMode = props.billing ? props.billing.mode : BillingMode.PAY_PER_REQUEST;

    this.configureReplicaTables(props);

    const resource = new CfnGlobalTable(this, 'Resource', {
      tableName: this.physicalName,
      keySchema: Lazy.any({ produce: () => this.keySchema }),
      attributeDefinitions: Lazy.any({ produce: () => this.attributeDefinitions }),
      replicas: this.replicas,
      streamSpecification: { streamViewType: NEW_AND_OLD_IMAGES },
      globalSecondaryIndexes: Lazy.any({ produce: () => this.configureGlobalSecondaryIndexes() }),
      timeToLiveSpecification: props.timeToLiveAttribute
        ? { attributeName: props.timeToLiveAttribute, enabled: true }
        : undefined,
      billingMode: this.billingMode,
      writeProvisionedThroughputSettings: this.billingMode === BillingMode.PROVISIONED
        ? this.configureWriteProvisionedThroughput(props.billing?.writeCapacity)
        : undefined,
    });
    resource.applyRemovalPolicy(props.removalPolicy);

    this.tableArn = this.getResourceArnAttribute(resource.attrArn, {
      service: 'dynamodb',
      resource: 'table',
      resourceName: this.physicalName,
    });
    this.tableName = this.getResourceNameAttribute(resource.ref);
    this.tableId = resource.attrTableId;
    this.tableStreamArn = resource.attrStreamArn;

    if (props.tableName) {
      this.node.addMetadata('aws:cdk:hasPhysicalName', this.tableName);
    }
  }

  private addKey(attribute: Attribute, keyType: string) {
    this.registerAttribute(attribute);
    this.keySchema.push({ attributeName: attribute.name, keyType });
  }

  private registerAttribute(attribute: Attribute) {
    const { name, type } = attribute;
    const existingDef = this.attributeDefinitions.find(def => def.attributeName === name);
    // attributes cannot be redefined
    if (existingDef && existingDef.attributeType !== type) {
      throw new Error(`Unable to specify ${name} as ${type} because it was already defined as ${existingDef.attributeType}`);
    }
    if (!existingDef) {
      this.attributeDefinitions.push({ attributeName: name, attributeType: type });
    }
  }

  private configureWriteProvisionedThroughput(writeCapacity: Capacity): CfnGlobalTable.WriteProvisionedThroughputSettingsProperty {
    this.validateWriteCapacity(writeCapacity);
    return {
      writeCapacityAutoScalingSettings: {
        minCapacity: writeCapacity.minCapacity!,
        maxCapacity: writeCapacity.maxCapacity!,
        targetTrackingScalingPolicyConfiguration: {
          targetValue: writeCapacity?.targetUtilizationPercent ?? DEFAULT_TARGET_UTILIZATION,
        },
      },
    };
  }

  private configureGlobalSecondaryIndexes() {
    for (const globalSecondaryIndex of this.globalSecondaryIndexes) {
      this.validateProvisioning({
        readCapacity: globalSecondaryIndex.readCapacity,
        writeCapacity: globalSecondaryIndex.writeCapacity,
      });
      this.validateIndexName(globalSecondaryIndex.indexName);
    }
  }

  private configureReplicaTables(props: TableOptions) {

  }

  private buildIndexKeySchema(partitionKey: Attribute, sortKey?: Attribute) {
    this.registerAttribute(partitionKey);
    const indexKeySchema: CfnGlobalTable.KeySchemaProperty[] = [
      { attributeName: partitionKey.name, keyType: HASH_KEY_TYPE },
    ];

    if (sortKey) {
      this.registerAttribute(sortKey);
      indexKeySchema.push({ attributeName: sortKey.name, keyType: RANGE_KEY_TYPE });
    }

    return indexKeySchema;
  }

  private buildIndexProjection() {

  }

  private validateWriteCapacity(writeCapacity: Capacity) {
    if (writeCapacity.mode === CapacityMode.FIXED) {
      throw new Error('The capacity mode for write capacity must be autoscaled');
    }
    if (writeCapacity.minCapacity === undefined || writeCapacity.maxCapacity === undefined) {
      throw new Error('Min and max capacity must be provided for autoscaled capacity setting');
    }
  }

  private validateProvisioning(props: { readCapacity?: Capacity, writeCapacity?: Capacity }) {
    if (this.billingMode === BillingMode.PAY_PER_REQUEST) {
      if (props.readCapacity || props.writeCapacity) {
        throw new Error('You cannot provision read and write capacity for a table with on-demand billing mode');
      }
    }
  }

  private validateIndexName(indexName: string) {

  }
}

/**
 * Capacity modes.
 */
export enum CapacityMode {
  /**
   * Fixed
   */
  FIXED = 'FIXED',

  /**
   * Autoscaled
   */
  AUTOSCALED = 'AUTOSCALED',
}

/**
 * The capacity mode to use for read and write operations on all replicas in the global table.
 */
export class Capacity {
  /**
   * Fixed capacity mode.
   */
  public static fixed(units: number) {
    return new Capacity(CapacityMode.FIXED, { units });
  }

  /**
   * Autoscaled capacity mode.
   */
  public static autoscaled(options: AutoscaledCapacityOptions) {
    return new Capacity(CapacityMode.AUTOSCALED, { autoscaledCapacityOptions: options });
  }

  /**
   * The capacity mode for read and write operations.
   */
  public readonly mode: string;

  /**
   * The capacity units for read and write operations.
   */
  public readonly units?: number;

  /**
   * The minimum capacity to scale to.
   */
  public readonly minCapacity?: number;

  /**
   * The maximum capacity to scale to.
   */
  public readonly maxCapacity?: number;

  /**
   * The target utilization percentage.
   */
  public readonly targetUtilizationPercent?: number;

  private constructor(mode: string, options: CapacityOptions = {}) {
    this.mode = mode;
    this.units = options.units;
    this.minCapacity = options.autoscaledCapacityOptions?.minCapacity;
    this.maxCapacity = options.autoscaledCapacityOptions?.maxCapacity;
    this.targetUtilizationPercent = options.autoscaledCapacityOptions?.targetUtilizationPercent;
  }
}

/**
 * Represents the billing used to specify how you are charged for read and write throughput
 * and how you manage capacity.
 */
export class Billing {
  /**
   * Configure on-demand billing.
   */
  public static onDemand() {
    return new Billing(BillingMode.PAY_PER_REQUEST);
  }

  /**
   * Configure provisioned billing.
   */
  public static provisioned(options: ThroughputOptions) {
    return new Billing(BillingMode.PROVISIONED, options);
  }

  /**
   * The billing mode used for read and write operations.
   */
  public readonly mode: string;

  /**
   * The read capacity.
   */
  public readonly readCapacity?: Capacity;

  /**
   * The write capacity.
   */
  public readonly writeCapacity?: Capacity;

  private constructor(mode: string, options?: ThroughputOptions) {
    this.mode = mode;
    this.readCapacity = options?.readCapacity;
    this.writeCapacity = options?.writeCapacity;
  }
}

export class Encryption {}
