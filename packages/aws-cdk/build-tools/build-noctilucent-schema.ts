import * as assert from 'assert';
import { promises as fs } from 'fs';
import * as path from 'path';

import * as Case from 'case';
// eslint-disable-next-line import/no-extraneous-dependencies
import { Assembly, ClassType, InterfaceType, ModuleLike, Type, TypeReference, TypeSystem } from 'jsii-reflect';
import { major } from 'semver';

const enum DocTag {
  CLOUDFORMATION_ATTRIBUTE = 'cloudformationAttribute',
  CLOUDFORMATION_PROPERTY = 'cloudformationProperty',
  CLOUDFORMATION_RESOURCE = 'cloudformationResource',
  CLOUDFORMATION_TRANSFORM = 'cloudformationTransform',
}

/*
 * This build script processes the jsii assembly for `aws-cdk-lib` in order to
 * extract a Noctilucent-specific schema to maximize accuracy of the
 * `cdk migrate` translations.
 */
async function main() {
  const system = new TypeSystem();
  const assm = await system.load(path.resolve(__dirname, '..', '..', 'aws-cdk-lib'), { validate: false });

  const { resourceTypes, namedTypes } = deriveSchema(assm);

  const outDir = path.join(__dirname, '..', 'lib', 'commands', 'migrate');
  await fs.mkdir(outDir, { recursive: true });

  const json = JSON.stringify(
    { resourceTypes, namedTypes, version: assm.version },
    (_key, val) => val instanceof Map ? Object.fromEntries(val.entries()) : val,
    2,
  );

  await fs.writeFile(path.join(outDir, '.gitignore'), '# Ignore all generated code\n*\n', 'utf-8');
  await fs.writeFile(path.join(outDir, 'resources.yml'), [
    '%YAML 1.2',
    '---',
    `# This file is generated by ${path.relative(outDir, __filename)}. All edits will be lost!`,
    json,
  ].join('\n'), 'utf-8');
}

interface ResourceSchema {
  /** The CDK construct to use for declaring a given CloudFormation resource type. */
  readonly construct: TypeName;

  /** The properties accepted by this construct. */
  readonly properties: ReadonlyMap<string, TypeScriptPropertyInfo>;

  /** The properties accepted by this construct. */
  readonly attributes: ReadonlyMap<string, TypeScriptPropertyInfo>;
}

interface TypeName {
  readonly ts: {
    readonly module: string;
    readonly name: string;
  };
  readonly dotnet: {
    readonly ns: string;
    readonly name: string;
  };
  readonly go: {
    readonly module: string;
    readonly package: string;
    readonly name: string;
  };
  readonly python: {
    readonly module: string;
    readonly name: string;
  };
}

interface TypeScriptPropertyInfo {
  /** The name of the TypeScript property. */
  name: string;
  /**
   * Whether the property can be null or undefined.
   *
   * @default false
   */
  nullable?: boolean;
  /** The type of this property. */
  valueType: PropertyType;
}

type PropertyType = PrimitiveType | ListType | MapType | NamedTypeRef | UnionType;
interface PrimitiveType {
  readonly primitive: string;
}
interface ListType {
  readonly listOf: PropertyType;
}
interface MapType {
  readonly mapOf: PropertyType;
}
interface NamedTypeRef {
  readonly named: string;
}
interface NamedType {
  /**
   * Whether this type has behavior (i.e: it's not a struct).
   *
   * @default false
   */
  readonly behavioral?: boolean;
  readonly properties: ReadonlyMap<string, TypeScriptPropertyInfo>;
}
interface UnionType {
  readonly union: readonly PropertyType[];
}

function deriveSchema(assm: Assembly): { readonly resourceTypes: Map<string, ResourceSchema>, namedTypes: Map<string, NamedType> } {
  const types = new Map<string, ClassType>();

  for (const clazz of assm.allClasses) {
    const typeName = clazz.docs?.customTag(DocTag.CLOUDFORMATION_RESOURCE);
    if (typeName == null) {
      continue;
    }

    const previous = types.get(typeName);
    if (previous != null && hasPrecedence(previous, clazz)) {
      continue;
    }

    types.set(typeName, clazz);
  }

  const resourceTypes = new Map<string, ResourceSchema>();
  const namedTypes = new Map<string, NamedType>();
  for (const [typeName, type] of types) {
    resourceTypes.set(typeName, {
      construct: typeNameOf(type),
      properties: renderProperties(type, namedTypes),
      attributes: renderAttributes(type, namedTypes),
    });
  }
  return { resourceTypes, namedTypes };
}

function renderProperties(type: ClassType | InterfaceType, namedTypes: Map<string, NamedType>) {
  return type.ownProperties.reduce(
    (props, prop) => {
      const cfnName = prop.docs.customTag(DocTag.CLOUDFORMATION_PROPERTY);
      if (cfnName != null) {
        props.set(cfnName, {
          name: prop.name,
          // We omit "nullable" if false, to reduce the output size.
          nullable: prop.optional || undefined,
          valueType: renderPropertyType(prop.type, namedTypes),
        });
      }
      return props;
    },
    new Map<string, TypeScriptPropertyInfo>(),
  );
}

function renderAttributes(type: ClassType | InterfaceType, namedTypes: Map<string, NamedType>) {
  return type.ownProperties.reduce(
    (attrs, attr) => {
      const cfnName = attr.docs.customTag(DocTag.CLOUDFORMATION_ATTRIBUTE);
      if (cfnName != null) {
        attrs.set(cfnName, {
          name: attr.name,
          // We omit "nullable" if false, to reduce the output size.
          nullable: attr.optional || undefined,
          valueType: renderPropertyType(attr.type, namedTypes),
        });
      }
      return attrs;
    },
    new Map<string, TypeScriptPropertyInfo>(),
  );
}

function renderPropertyType(type: TypeReference, namedTypes: Map<string, NamedType>): PropertyType {
  if (type.primitive) {
    return { primitive: type.primitive };
  }
  if (type.arrayOfType) {
    return { listOf: renderPropertyType(type.arrayOfType, namedTypes) };
  }
  if (type.mapOfType) {
    return { mapOf: renderPropertyType(type.mapOfType, namedTypes) };
  }
  if (type.type?.isClassType() || type.type?.isInterfaceType()) {
    if (!namedTypes.has(type.type.fqn)) {
      const properties = new Map();
      namedTypes.set(type.type.fqn, { properties, behavioral: type.type.isDataType() ? undefined : true });
      // Now overriding properties to the correct value...
      for (const [key, value] of renderProperties(type.type, namedTypes)) {
        properties.set(key, value);
      }
    }

    return { named: type.type.fqn };
  }
  if (type.unionOfTypes) {
    const union = type.unionOfTypes
      .map((pt) => renderPropertyType(pt, namedTypes));
    if (union.length === 1) {
      return union[0];
    } else if (union.length === 0) {
      return { primitive: 'any' };
    }
    return { union };
  }
  throw new Error(`Unsupported type reference: ${type}`);
}

function typeNameOf(type: Type): TypeName {
  const moduleLike = resolveModuleLike(type);
  const moduleLikeParts = moduleLike.fqn.split('.');
  const moduleLikeName = moduleLikeParts[moduleLikeParts.length - 1];

  const nestingParent = type.nestingParent && typeNameOf(type.nestingParent);

  return {
    ts: {
      module: nestingParent?.ts.module ?? moduleLike.fqn.split('.').map((seg) => seg.replace('_', '-')).join('/'),
      name: nestingParent ? `${nestingParent.ts.name}.${type.name}` : type.name,
    },
    dotnet: {
      ns: nestingParent
        ? nestingParent.dotnet.ns
        : dotnetNamespace(type.assembly, moduleLike),
      name: nestingParent ? `${nestingParent.dotnet.name}.${type.name}` : type.name,
    },
    go: {
      module: nestingParent?.go.module ?? goModule(type.assembly, moduleLike),
      package: nestingParent?.go.package ?? moduleLike.targets?.go?.packageName ?? moduleLikeName.toLowerCase().replace(/[-_]/g, ''),
      name: nestingParent ? `${nestingParent.go.name}_${type.name}` : type.name,
    },
    python: {
      module: nestingParent?.python.module ?? pythonModule(type.assembly, moduleLike),
      name: nestingParent ? `${nestingParent.python.name}.${type.name}` : type.name,
    },
  };
}

function resolveModuleLike(type: Type): ModuleLike {
  if (type.nestingParent) {
    return resolveModuleLike(type.nestingParent);
  }
  if (type.namespace) {
    const fqNamespace = `${type.assembly.name}.${type.namespace}`;
    const submodule = type.assembly.allSubmodules.find((mod) => mod.fqn === fqNamespace);
    assert(submodule != null, `could not find submodule for ns ${type.namespace} within ${type.assembly.name}`);
    return submodule;
  }
  return type.assembly;
}

function dotnetNamespace(assm: Assembly, module: ModuleLike): string {
  if (module.targets?.dotnet?.namespace) {
    return module.targets.dotnet.namespace;
  }

  const parts = module.fqn.split('.');
  assert(parts.length > 1, `no dotnet namespace was configured for ${module.fqn}: ${JSON.stringify(module.targets?.dotnet, null, 2)}`);

  const parentFqn = parts.slice(0, parts.length - 1).join('.');
  const parentModuleLike = parentFqn === assm.name ? assm : assm.allSubmodules.find((mod) => mod.fqn === parentFqn);
  assert(parentModuleLike != null, `could not find parent module for ${module.fqn} (named ${parentFqn})`);
  const parent = dotnetNamespace(
    assm,
    parentModuleLike,
  );

  return `${parent}.${Case.pascal(parts[parts.length - 1])}`;
}

function goModule(assm: Assembly, module: ModuleLike): string {
  if (module.targets?.go?.moduleName) {
    const mv = major(assm.version);
    return module.fqn === assm.name && (assm.version === '0.0.0' || mv > 1)
      ? `${module.targets.go.moduleName}/${module.targets.go.packageName}/v${mv || 2}`
      : module.targets.go.moduleName;
  }

  const parts = module.fqn.split('.');
  assert(parts.length > 1, `no go module was configured for ${module.fqn}: ${JSON.stringify(module.targets?.go, null, 2)}`);

  const parentFqn = parts.slice(0, parts.length - 1).join('.');
  const parentModuleLike = parentFqn === assm.name ? assm : assm.allSubmodules.find((mod) => mod.fqn === parentFqn);
  assert(parentModuleLike != null, `could not find parent module for ${module.fqn} (named ${parentFqn})`);
  const parent = goModule(
    assm,
    parentModuleLike,
  );

  const packageName = module.targets?.go?.packageName ?? parts[parts.length - 1].toLowerCase().replace(/[-_]/g, '');

  return `${parent}/${packageName}`;
}

function pythonModule(assm: Assembly, module: ModuleLike): string {
  if (module.targets?.python?.module) {
    return module.targets.python.module;
  }

  const parts = module.fqn.split('.');
  assert(parts.length > 1, `no python module was configured for ${module.fqn}: ${JSON.stringify(module.targets?.python, null, 2)}`);

  const parentFqn = parts.slice(0, parts.length - 1).join('.');
  const parentModuleLike = parentFqn === assm.name ? assm : assm.allSubmodules.find((mod) => mod.fqn === parentFqn);
  assert(parentModuleLike != null, `could not find parent module for ${module.fqn} (named ${parentFqn})`);
  const parent = pythonModule(assm, parentModuleLike);

  return `${parent}.${Case.snake(parts[parts.length - 1])}`;
}

/**
 * Some CloudFormation resource types are generated several times at different
 * places in the `aws-cdk-lib` packgae. This function helps decide on exactly
 * one type to use in a consistent manner.
 *
 * @param type the type currently being considered as "most relevant".
 * @param over the new type being investigated.
 *
 * @returns true if `type` should be kept, `false` if it should be replaced by
 *          `over`.
 */
function hasPrecedence(type: ClassType, over: ClassType): boolean {
  // If one of them is @deprecated, keep the other one...
  if (type.docs.deprecated !== over.docs.deprecated) {
    return over.docs.deprecated;
  }

  // If exactly one of them has no namespace, keep that one.
  // This is the case for AWS::CloudFormation::* resources for example.
  if ((type.namespace == null) != (over.namespace == null)) {
    return type.namespace == null;
  }

  // If one of them is in a "V2" namespace and the other isn't, keep the one that isn't.
  // This is the case for AWS::KinesisAnalyticsV2::* resources for example.
  if (over.namespace != null && type.namespace === `${over.namespace}v2`) {
    return true;
  } else if (type.namespace != null && over.namespace === `${type.namespace}v2`) {
    return false;
  }

  throw new Error(`Could not decide with has priority between ${type.fqn} and ${over.fqn}`);
}

// eslint-disable-next-line no-console
console.time(path.basename(__filename));
main().catch((error) => {
  // eslint-disable-next-line no-console
  console.error(error);
  process.exitCode = 1;
}).finally(
  // eslint-disable-next-line no-console
  () => console.timeEnd(path.basename(__filename)),
);
